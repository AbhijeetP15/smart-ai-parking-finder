{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { Component } from '@angular/core';\nimport { Subject, takeUntil } from 'rxjs';\nlet ParkingDashboardComponent = class ParkingDashboardComponent {\n  constructor(parkingService, router) {\n    this.parkingService = parkingService;\n    this.router = router;\n    this.parkingLots = [];\n    this.filteredLots = [];\n    this.selectedLot = null;\n    this.stats = null;\n    this.isLoading = false;\n    this.isConnected = false;\n    this.error = null;\n    this.filterType = 'all';\n    this.searchQuery = '';\n    this.destroy$ = new Subject();\n  }\n  ngOnInit() {\n    this.loadParkingLots();\n    // REMOVED: this.loadStats(); - We calculate stats from parking lots now\n    this.subscribeToRealtimeUpdates();\n    this.monitorConnectionStatus();\n  }\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n    this.parkingService.disconnect();\n  }\n  loadParkingLots() {\n    this.isLoading = true;\n    this.error = null;\n    this.parkingService.getAllParkingLots().pipe(takeUntil(this.destroy$)).subscribe({\n      next: lots => {\n        this.parkingLots = lots;\n        this.applyFilters();\n        this.calculateStatsFromLots(); // ADDED: Calculate stats after loading lots\n        this.isLoading = false;\n        lots.forEach(lot => this.parkingService.subscribeToParkingLot(lot.id));\n      },\n      error: err => {\n        this.error = 'Failed to load parking lots. Please try again.';\n        this.isLoading = false;\n        console.error(err);\n      }\n    });\n  }\n  calculateStatsFromLots() {\n    if (this.parkingLots.length > 0) {\n      const totalSpots = this.parkingLots.reduce((sum, lot) => sum + lot.totalSpots, 0);\n      const totalAvailable = this.parkingLots.reduce((sum, lot) => sum + lot.availableSpots, 0);\n      const avgOccupancy = (totalSpots - totalAvailable) / totalSpots * 100;\n      this.stats = {\n        totalParkingLots: this.parkingLots.length,\n        totalSpots: totalSpots,\n        totalAvailable: totalAvailable,\n        avgOccupancy: parseFloat(avgOccupancy.toFixed(1))\n      };\n    }\n  }\n  // REMOVED: loadStats() method - No longer needed\n  subscribeToRealtimeUpdates() {\n    this.parkingService.parkingUpdates$.pipe(takeUntil(this.destroy$)).subscribe({\n      next: update => {\n        console.log('Received parking update:', update);\n        const lotIndex = this.parkingLots.findIndex(lot => lot.id === update.lotId);\n        if (lotIndex !== -1) {\n          this.parkingLots[lotIndex] = {\n            ...this.parkingLots[lotIndex],\n            availableSpots: update.availableSpots,\n            lastUpdate: update.timestamp\n          };\n          this.applyFilters();\n        }\n        if (this.selectedLot?.id === update.lotId) {\n          this.selectedLot = {\n            ...this.selectedLot,\n            availableSpots: update.availableSpots,\n            lastUpdate: update.timestamp\n          };\n        }\n        this.calculateStatsFromLots(); // CHANGED: Calculate stats instead of loading from API\n      },\n\n      error: err => {\n        console.error('Real-time update error:', err);\n      }\n    });\n  }\n  monitorConnectionStatus() {\n    this.parkingService.connectionStatus$.pipe(takeUntil(this.destroy$)).subscribe({\n      next: status => {\n        this.isConnected = status;\n        if (!status) {\n          console.warn('WebSocket disconnected. Will attempt to reconnect...');\n        }\n      }\n    });\n  }\n  selectLot(lot) {\n    // Navigate to detail page\n    this.router.navigate(['/parking', lot.id]);\n  }\n  refreshData() {\n    this.loadParkingLots(); // CHANGED: Only need to load lots, stats are calculated automatically\n  }\n\n  setFilter(filter) {\n    this.filterType = filter;\n    this.applyFilters();\n  }\n  onSearchChange(query) {\n    this.searchQuery = query;\n    this.applyFilters();\n  }\n  applyFilters() {\n    let filtered = [...this.parkingLots];\n    if (this.filterType !== 'all') {\n      filtered = filtered.filter(lot => {\n        const occupancy = this.getOccupancyRate(lot);\n        switch (this.filterType) {\n          case 'available':\n            return occupancy < 50;\n          case 'moderate':\n            return occupancy >= 50 && occupancy < 80;\n          case 'full':\n            return occupancy >= 80;\n          default:\n            return true;\n        }\n      });\n    }\n    if (this.searchQuery.trim()) {\n      const query = this.searchQuery.toLowerCase();\n      filtered = filtered.filter(lot => lot.name.toLowerCase().includes(query));\n    }\n    this.filteredLots = filtered;\n  }\n  getOccupancyRate(lot) {\n    return (lot.totalSpots - lot.availableSpots) / lot.totalSpots * 100;\n  }\n  getStatusLabel(lot) {\n    const occupancy = this.getOccupancyRate(lot);\n    if (occupancy < 50) return 'Available';\n    if (occupancy < 80) return 'Moderate';\n    return 'Full';\n  }\n  getStatusColor(lot) {\n    const occupancy = this.getOccupancyRate(lot);\n    if (occupancy < 50) return 'green';\n    if (occupancy < 80) return 'yellow';\n    return 'red';\n  }\n  formatLastUpdate(timestamp) {\n    const date = new Date(timestamp);\n    return date.toLocaleTimeString();\n  }\n  getTimeDifference(lot) {\n    return lot.predictedAvailability - lot.availableSpots;\n  }\n  getTrendIcon(lot) {\n    const diff = this.getTimeDifference(lot);\n    if (diff > 0) return '↑';\n    if (diff < 0) return '↓';\n    return '→';\n  }\n  getTrendMessage(lot) {\n    const diff = this.getTimeDifference(lot);\n    if (diff > 5) return 'More spots expected to open up soon!';\n    if (diff < -5) return 'Spots are filling up. Consider arriving soon.';\n    return 'Availability expected to remain stable.';\n  }\n  openInMaps(lot) {\n    const url = `https://www.google.com/maps?q=${lot.location.lat},${lot.location.lng}`;\n    window.open(url, '_blank');\n  }\n  getDirections(lot) {\n    if (navigator.geolocation) {\n      navigator.geolocation.getCurrentPosition(position => {\n        const {\n          latitude,\n          longitude\n        } = position.coords;\n        const url = `https://www.google.com/maps/dir/${latitude},${longitude}/${lot.location.lat},${lot.location.lng}`;\n        window.open(url, '_blank');\n      }, error => {\n        console.error('Geolocation error:', error);\n        this.openInMaps(lot);\n      });\n    } else {\n      this.openInMaps(lot);\n    }\n  }\n};\nParkingDashboardComponent = __decorate([Component({\n  selector: 'app-parking-dashboard',\n  templateUrl: './parking-dashboard.component.html',\n  styleUrls: ['./parking-dashboard.component.css']\n})], ParkingDashboardComponent);\nexport { ParkingDashboardComponent };","map":{"version":3,"mappings":"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","names":["Component","Subject","takeUntil","ParkingDashboardComponent","constructor","parkingService","router","ngOnInit","loadParkingLots","subscribeToRealtimeUpdates","monitorConnectionStatus","ngOnDestroy","destroy$","next","complete","disconnect","isLoading","error","getAllParkingLots","pipe","subscribe","lots","parkingLots","applyFilters","calculateStatsFromLots","forEach","lot","subscribeToParkingLot","id","err","console","length","totalSpots","reduce","sum","totalAvailable","availableSpots","avgOccupancy","stats","totalParkingLots","parseFloat","toFixed","parkingUpdates$","update","log","lotIndex","findIndex","lotId","lastUpdate","timestamp","selectedLot","connectionStatus$","status","isConnected","warn","selectLot","navigate","refreshData","setFilter","filter","filterType","onSearchChange","query","searchQuery","filtered","occupancy","getOccupancyRate","trim","toLowerCase","name","includes","filteredLots","getStatusLabel","getStatusColor","formatLastUpdate","date","Date","toLocaleTimeString","getTimeDifference","predictedAvailability","getTrendIcon","diff","getTrendMessage","openInMaps","url","location","lat","lng","window","open","getDirections","navigator","geolocation","getCurrentPosition","position","latitude","longitude","coords","selector","templateUrl","styleUrls"],"sourceRoot":"","sources":["C:\\Users\\abhij\\Documents\\Smart-AI Parking Finder\\frontend\\src\\app\\components\\parking-dashboard\\parking-dashboard.component.ts"],"sourcesContent":["import { Component, OnInit, OnDestroy } from '@angular/core';\r\nimport { Subject, takeUntil } from 'rxjs';\r\nimport { ParkingService, ParkingLot, Stats } from '../../services/parking.service';\r\nimport { Router } from '@angular/router'; \r\n\r\n@Component({\r\n  selector: 'app-parking-dashboard',\r\n  templateUrl: './parking-dashboard.component.html',\r\n  styleUrls: ['./parking-dashboard.component.css']\r\n})\r\nexport class ParkingDashboardComponent implements OnInit, OnDestroy {\r\n  parkingLots: ParkingLot[] = [];\r\n  filteredLots: ParkingLot[] = [];\r\n  selectedLot: ParkingLot | null = null;\r\n  stats: Stats | null = null;\r\n  \r\n  isLoading = false;\r\n  isConnected = false;\r\n  error: string | null = null;\r\n  \r\n  filterType: 'all' | 'available' | 'moderate' | 'full' = 'all';\r\n  searchQuery = '';\r\n  \r\n  private destroy$ = new Subject<void>();\r\n\r\n  constructor(private parkingService: ParkingService, private router: Router) {}\r\n\r\n  ngOnInit(): void {\r\n    this.loadParkingLots();\r\n    // REMOVED: this.loadStats(); - We calculate stats from parking lots now\r\n    this.subscribeToRealtimeUpdates();\r\n    this.monitorConnectionStatus();\r\n  }\r\n  \r\n\r\n  ngOnDestroy(): void {\r\n    this.destroy$.next();\r\n    this.destroy$.complete();\r\n    this.parkingService.disconnect();\r\n  }\r\n\r\n  loadParkingLots(): void {\r\n    this.isLoading = true;\r\n    this.error = null;\r\n\r\n    this.parkingService.getAllParkingLots()\r\n      .pipe(takeUntil(this.destroy$))\r\n      .subscribe({\r\n        next: (lots) => {\r\n          this.parkingLots = lots;\r\n          this.applyFilters();\r\n          this.calculateStatsFromLots(); // ADDED: Calculate stats after loading lots\r\n          this.isLoading = false;\r\n          \r\n          lots.forEach(lot => this.parkingService.subscribeToParkingLot(lot.id));\r\n        },\r\n        error: (err) => {\r\n          this.error = 'Failed to load parking lots. Please try again.';\r\n          this.isLoading = false;\r\n          console.error(err);\r\n        }\r\n      });\r\n  }\r\n\r\n  calculateStatsFromLots(): void {\r\n    if (this.parkingLots.length > 0) {\r\n      const totalSpots = this.parkingLots.reduce((sum, lot) => sum + lot.totalSpots, 0);\r\n      const totalAvailable = this.parkingLots.reduce((sum, lot) => sum + lot.availableSpots, 0);\r\n      const avgOccupancy = ((totalSpots - totalAvailable) / totalSpots * 100);\r\n\r\n      this.stats = {\r\n        totalParkingLots: this.parkingLots.length,\r\n        totalSpots: totalSpots,\r\n        totalAvailable: totalAvailable,\r\n        avgOccupancy: parseFloat(avgOccupancy.toFixed(1))\r\n      };\r\n    }\r\n  }\r\n\r\n  // REMOVED: loadStats() method - No longer needed\r\n\r\n  subscribeToRealtimeUpdates(): void {\r\n    this.parkingService.parkingUpdates$\r\n      .pipe(takeUntil(this.destroy$))\r\n      .subscribe({\r\n        next: (update) => {\r\n          console.log('Received parking update:', update);\r\n          \r\n          const lotIndex = this.parkingLots.findIndex(lot => lot.id === update.lotId);\r\n          if (lotIndex !== -1) {\r\n            this.parkingLots[lotIndex] = {\r\n              ...this.parkingLots[lotIndex],\r\n              availableSpots: update.availableSpots,\r\n              lastUpdate: update.timestamp\r\n            };\r\n            this.applyFilters();\r\n          }\r\n\r\n          if (this.selectedLot?.id === update.lotId) {\r\n            this.selectedLot = {\r\n              ...this.selectedLot,\r\n              availableSpots: update.availableSpots,\r\n              lastUpdate: update.timestamp\r\n            };\r\n          }\r\n\r\n          this.calculateStatsFromLots(); // CHANGED: Calculate stats instead of loading from API\r\n        },\r\n        error: (err) => {\r\n          console.error('Real-time update error:', err);\r\n        }\r\n      });\r\n  }\r\n\r\n  monitorConnectionStatus(): void {\r\n    this.parkingService.connectionStatus$\r\n      .pipe(takeUntil(this.destroy$))\r\n      .subscribe({\r\n        next: (status) => {\r\n          this.isConnected = status;\r\n          if (!status) {\r\n            console.warn('WebSocket disconnected. Will attempt to reconnect...');\r\n          }\r\n        }\r\n      });\r\n  }\r\n\r\n  selectLot(lot: ParkingLot): void {\r\n  // Navigate to detail page\r\n  this.router.navigate(['/parking', lot.id]);\r\n}\r\n\r\n  refreshData(): void {\r\n    this.loadParkingLots(); // CHANGED: Only need to load lots, stats are calculated automatically\r\n  }\r\n\r\n  setFilter(filter: 'all' | 'available' | 'moderate' | 'full'): void {\r\n    this.filterType = filter;\r\n    this.applyFilters();\r\n  }\r\n\r\n  onSearchChange(query: string): void {\r\n    this.searchQuery = query;\r\n    this.applyFilters();\r\n  }\r\n\r\n  applyFilters(): void {\r\n    let filtered = [...this.parkingLots];\r\n\r\n    if (this.filterType !== 'all') {\r\n      filtered = filtered.filter(lot => {\r\n        const occupancy = this.getOccupancyRate(lot);\r\n        switch (this.filterType) {\r\n          case 'available':\r\n            return occupancy < 50;\r\n          case 'moderate':\r\n            return occupancy >= 50 && occupancy < 80;\r\n          case 'full':\r\n            return occupancy >= 80;\r\n          default:\r\n            return true;\r\n        }\r\n      });\r\n    }\r\n\r\n    if (this.searchQuery.trim()) {\r\n      const query = this.searchQuery.toLowerCase();\r\n      filtered = filtered.filter(lot => \r\n        lot.name.toLowerCase().includes(query)\r\n      );\r\n    }\r\n\r\n    this.filteredLots = filtered;\r\n  }\r\n\r\n  getOccupancyRate(lot: ParkingLot): number {\r\n    return ((lot.totalSpots - lot.availableSpots) / lot.totalSpots) * 100;\r\n  }\r\n\r\n  getStatusLabel(lot: ParkingLot): string {\r\n    const occupancy = this.getOccupancyRate(lot);\r\n    if (occupancy < 50) return 'Available';\r\n    if (occupancy < 80) return 'Moderate';\r\n    return 'Full';\r\n  }\r\n\r\n  getStatusColor(lot: ParkingLot): string {\r\n    const occupancy = this.getOccupancyRate(lot);\r\n    if (occupancy < 50) return 'green';\r\n    if (occupancy < 80) return 'yellow';\r\n    return 'red';\r\n  }\r\n\r\n  formatLastUpdate(timestamp: string): string {\r\n    const date = new Date(timestamp);\r\n    return date.toLocaleTimeString();\r\n  }\r\n\r\n  getTimeDifference(lot: ParkingLot): number {\r\n    return lot.predictedAvailability - lot.availableSpots;\r\n  }\r\n\r\n  getTrendIcon(lot: ParkingLot): string {\r\n    const diff = this.getTimeDifference(lot);\r\n    if (diff > 0) return '↑';\r\n    if (diff < 0) return '↓';\r\n    return '→';\r\n  }\r\n\r\n  getTrendMessage(lot: ParkingLot): string {\r\n    const diff = this.getTimeDifference(lot);\r\n    if (diff > 5) return 'More spots expected to open up soon!';\r\n    if (diff < -5) return 'Spots are filling up. Consider arriving soon.';\r\n    return 'Availability expected to remain stable.';\r\n  }\r\n\r\n  openInMaps(lot: ParkingLot): void {\r\n    const url = `https://www.google.com/maps?q=${lot.location.lat},${lot.location.lng}`;\r\n    window.open(url, '_blank');\r\n  }\r\n\r\n  getDirections(lot: ParkingLot): void {\r\n    if (navigator.geolocation) {\r\n      navigator.geolocation.getCurrentPosition(\r\n        (position) => {\r\n          const { latitude, longitude } = position.coords;\r\n          const url = `https://www.google.com/maps/dir/${latitude},${longitude}/${lot.location.lat},${lot.location.lng}`;\r\n          window.open(url, '_blank');\r\n        },\r\n        (error) => {\r\n          console.error('Geolocation error:', error);\r\n          this.openInMaps(lot);\r\n        }\r\n      );\r\n    } else {\r\n      this.openInMaps(lot);\r\n    }\r\n  }\r\n}"]},"metadata":{},"sourceType":"module","externalDependencies":[]}