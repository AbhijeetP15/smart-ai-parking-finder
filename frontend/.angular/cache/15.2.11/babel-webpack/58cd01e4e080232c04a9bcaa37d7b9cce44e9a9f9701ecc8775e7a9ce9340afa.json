{"ast":null,"code":"import { HttpParams } from '@angular/common/http';\nimport { BehaviorSubject, Subject } from 'rxjs';\nimport { map, catchError, tap } from 'rxjs/operators';\nimport { io } from 'socket.io-client';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class ParkingService {\n  constructor(http) {\n    this.http = http;\n    this.apiUrl = 'http://localhost:3000/api';\n    this.parkingLotsSubject = new BehaviorSubject([]);\n    this.parkingLots$ = this.parkingLotsSubject.asObservable();\n    this.parkingUpdateSubject = new Subject();\n    this.parkingUpdates$ = this.parkingUpdateSubject.asObservable();\n    this.connectionStatusSubject = new BehaviorSubject(false);\n    this.connectionStatus$ = this.connectionStatusSubject.asObservable();\n    // Add this property at the top of the class\n    this.useRealData = true; // Toggle this to switch data sources\n    this.initializeWebSocket();\n  }\n  initializeWebSocket() {\n    this.socket = io('http://localhost:3000', {\n      reconnection: true,\n      reconnectionDelay: 1000,\n      reconnectionAttempts: 5\n    });\n    this.socket.on('connect', () => {\n      console.log('WebSocket connected');\n      this.connectionStatusSubject.next(true);\n    });\n    this.socket.on('disconnect', () => {\n      console.log('WebSocket disconnected');\n      this.connectionStatusSubject.next(false);\n    });\n    this.socket.on('parking-update', update => {\n      this.parkingUpdateSubject.next(update);\n      this.updateLocalParkingLot(update);\n    });\n    this.socket.on('connect_error', error => {\n      console.error('WebSocket connection error:', error);\n    });\n  }\n  updateLocalParkingLot(update) {\n    const currentLots = this.parkingLotsSubject.value;\n    const updatedLots = currentLots.map(lot => lot.id === update.lotId ? {\n      ...lot,\n      availableSpots: update.availableSpots,\n      lastUpdate: update.timestamp\n    } : lot);\n    this.parkingLotsSubject.next(updatedLots);\n  }\n  lotsBasePath() {\n    return this.useRealData ? `${this.apiUrl}/parking-lots/real` : `${this.apiUrl}/parking-lots`;\n  }\n  getAllParkingLots(lat, lng, radius) {\n    // Only the 'real' path uses lat/lng/radius; the simulated one ignores them\n    let endpoint = this.lotsBasePath();\n    if (this.useRealData) {\n      // defaults if not passed (ASU)\n      const qLat = (lat ?? 33.4242).toFixed(6);\n      const qLng = (lng ?? -111.9281).toFixed(6);\n      const qRad = radius ?? 5000; // meters\n      endpoint = `${endpoint}?lat=${qLat}&lng=${qLng}&radius=${qRad}`;\n    }\n    return this.http.get(endpoint).pipe(tap(lots => this.parkingLotsSubject.next(lots)), catchError(err => {\n      console.error('Error fetching parking lots:', err);\n      throw err;\n    }));\n  }\n  // Add this method to toggle between real and simulated data\n  setUseRealData(useReal) {\n    this.useRealData = useReal;\n  }\n  getParkingLotById(id) {\n    // IMPORTANT: hit the same source as the list:\n    // /real/:id when using real data, otherwise /:id\n    const endpoint = this.useRealData ? `${this.lotsBasePath()}/${id}` // -> /api/parking-lots/real/:id\n    : `${this.lotsBasePath()}/${id}`; // -> /api/parking-lots/:id\n    return this.http.get(endpoint).pipe(catchError(error => {\n      console.error(`Error fetching parking lot ${id}:`, error);\n      throw error;\n    }));\n  }\n  updateParkingLot(id, availableSpots, sensors) {\n    const body = {\n      availableSpots,\n      sensors\n    };\n    return this.http.put(`${this.apiUrl}/parking-lots/${id}`, body).pipe(catchError(error => {\n      console.error(`Error updating parking lot ${id}:`, error);\n      throw error;\n    }));\n  }\n  getPrediction(id, minutesAhead = 30) {\n    const params = new HttpParams().set('minutes', minutesAhead.toString());\n    return this.http.get(`${this.apiUrl}/parking-lots/${id}/predict`, {\n      params\n    }).pipe(catchError(error => {\n      console.error(`Error fetching prediction for lot ${id}:`, error);\n      throw error;\n    }));\n  }\n  getHistoricalData(id, limit = 100) {\n    const params = new HttpParams().set('limit', limit.toString());\n    return this.http.get(`${this.apiUrl}/parking-lots/${id}/history`, {\n      params\n    }).pipe(catchError(error => {\n      console.error(`Error fetching historical data for lot ${id}:`, error);\n      throw error;\n    }));\n  }\n  getStats() {\n    return this.http.get(`${this.apiUrl}/stats`).pipe(catchError(error => {\n      console.error('Error fetching stats:', error);\n      throw error;\n    }));\n  }\n  createParkingLot(lot) {\n    return this.http.post(`${this.apiUrl}/parking-lots`, lot).pipe(tap(newLot => {\n      const currentLots = this.parkingLotsSubject.value;\n      this.parkingLotsSubject.next([...currentLots, newLot]);\n    }), catchError(error => {\n      console.error('Error creating parking lot:', error);\n      throw error;\n    }));\n  }\n  subscribeToParkingLot(lotId) {\n    if (this.socket.connected) {\n      this.socket.emit('subscribe', lotId);\n      console.log(`Subscribed to parking lot: ${lotId}`);\n    } else {\n      console.warn('Socket not connected. Will subscribe when connection is established.');\n      this.socket.once('connect', () => {\n        this.socket.emit('subscribe', lotId);\n      });\n    }\n  }\n  unsubscribeFromParkingLot(lotId) {\n    if (this.socket.connected) {\n      this.socket.emit('unsubscribe', lotId);\n      console.log(`Unsubscribed from parking lot: ${lotId}`);\n    }\n  }\n  getOccupancyRate(lot) {\n    return (lot.totalSpots - lot.availableSpots) / lot.totalSpots * 100;\n  }\n  getStatusLabel(lot) {\n    const occupancy = this.getOccupancyRate(lot);\n    if (occupancy < 50) return 'Available';\n    if (occupancy < 80) return 'Moderate';\n    return 'Full';\n  }\n  getStatusColor(lot) {\n    const occupancy = this.getOccupancyRate(lot);\n    if (occupancy < 50) return 'green';\n    if (occupancy < 80) return 'yellow';\n    return 'red';\n  }\n  calculateDistance(lat1, lng1, lat2, lng2) {\n    const R = 6371;\n    const dLat = this.toRad(lat2 - lat1);\n    const dLng = this.toRad(lng2 - lng1);\n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(this.toRad(lat1)) * Math.cos(this.toRad(lat2)) * Math.sin(dLng / 2) * Math.sin(dLng / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return R * c;\n  }\n  toRad(degrees) {\n    return degrees * (Math.PI / 180);\n  }\n  getNearestParkingLot(userLat, userLng) {\n    return this.parkingLots$.pipe(map(lots => {\n      if (lots.length === 0) return null;\n      let nearest = lots[0];\n      let minDistance = this.calculateDistance(userLat, userLng, nearest.location.lat, nearest.location.lng);\n      lots.forEach(lot => {\n        const distance = this.calculateDistance(userLat, userLng, lot.location.lat, lot.location.lng);\n        if (distance < minDistance) {\n          minDistance = distance;\n          nearest = lot;\n        }\n      });\n      return nearest;\n    }));\n  }\n  filterByAvailability(lots, minSpots) {\n    return lots.filter(lot => lot.availableSpots >= minSpots);\n  }\n  sortByAvailability(lots) {\n    return [...lots].sort((a, b) => b.availableSpots - a.availableSpots);\n  }\n  disconnect() {\n    if (this.socket) {\n      this.socket.disconnect();\n      console.log('WebSocket disconnected manually');\n    }\n  }\n  reconnect() {\n    if (this.socket) {\n      this.socket.connect();\n      console.log('WebSocket reconnecting...');\n    }\n  }\n  static {\n    this.ɵfac = function ParkingService_Factory(t) {\n      return new (t || ParkingService)(i0.ɵɵinject(i1.HttpClient));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: ParkingService,\n      factory: ParkingService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["HttpParams","BehaviorSubject","Subject","map","catchError","tap","io","ParkingService","constructor","http","parkingLotsSubject","asObservable","parkingUpdateSubject","connectionStatusSubject","initializeWebSocket","socket","reconnection","reconnectionDelay","reconnectionAttempts","on","console","log","next","update","updateLocalParkingLot","error","currentLots","value","updatedLots","lot","id","lotId","availableSpots","lastUpdate","timestamp","lotsBasePath","useRealData","apiUrl","getAllParkingLots","lat","lng","radius","endpoint","qLat","toFixed","qLng","qRad","get","pipe","lots","err","setUseRealData","useReal","getParkingLotById","updateParkingLot","sensors","body","put","getPrediction","minutesAhead","params","set","toString","getHistoricalData","limit","getStats","createParkingLot","post","newLot","subscribeToParkingLot","connected","emit","warn","once","unsubscribeFromParkingLot","getOccupancyRate","totalSpots","getStatusLabel","occupancy","getStatusColor","calculateDistance","lat1","lng1","lat2","lng2","R","dLat","toRad","dLng","a","Math","sin","cos","c","atan2","sqrt","degrees","PI","getNearestParkingLot","userLat","userLng","parkingLots$","length","nearest","minDistance","location","forEach","distance","filterByAvailability","minSpots","filter","sortByAvailability","sort","b","disconnect","reconnect","connect","factory","providedIn"],"sourceRoot":"","sources":["C:\\Users\\abhij\\Documents\\Smart-AI Parking Finder\\frontend\\src\\app\\services\\parking.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { HttpClient, HttpParams } from '@angular/common/http';\r\nimport { Observable, BehaviorSubject, Subject } from 'rxjs';\r\nimport { map, catchError, tap } from 'rxjs/operators';\r\nimport { io, Socket } from 'socket.io-client';\r\n\r\nexport interface Location {\r\n  lat: number;\r\n  lng: number;\r\n}\r\n\r\nexport interface Sensor {\r\n  spotId: string;\r\n  isOccupied: boolean;\r\n  lastUpdate: Date;\r\n}\r\n\r\nexport interface ParkingLot {\r\n  id: string;\r\n  name: string;\r\n  totalSpots: number;\r\n  availableSpots: number;\r\n  location: Location;\r\n  lastUpdate: string;\r\n  predictedAvailability: number;\r\n  confidence: number;\r\n  sensors?: Sensor[];\r\n}\r\n\r\nexport interface PredictionResponse {\r\n  predictedSpots: number;\r\n  confidence: number;\r\n  predictedFor: string;\r\n}\r\n\r\nexport interface HistoricalData {\r\n  parkingLotId: string;\r\n  timestamp: string;\r\n  availableSpots: number;\r\n  occupancyRate: number;\r\n  dayOfWeek: number;\r\n  hour: number;\r\n}\r\n\r\nexport interface Stats {\r\n  totalParkingLots: number;\r\n  totalSpots: number;\r\n  totalAvailable: number;\r\n  avgOccupancy: number;\r\n}\r\n\r\nexport interface ParkingUpdate {\r\n  lotId: string;\r\n  availableSpots: number;\r\n  timestamp: string;\r\n}\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class ParkingService {\r\n  private apiUrl = 'http://localhost:3000/api';\r\n  private socket!: Socket;\r\n  \r\n  private parkingLotsSubject = new BehaviorSubject<ParkingLot[]>([]);\r\n  public parkingLots$ = this.parkingLotsSubject.asObservable();\r\n  \r\n  private parkingUpdateSubject = new Subject<ParkingUpdate>();\r\n  public parkingUpdates$ = this.parkingUpdateSubject.asObservable();\r\n  \r\n  private connectionStatusSubject = new BehaviorSubject<boolean>(false);\r\n  public connectionStatus$ = this.connectionStatusSubject.asObservable();\r\n\r\n  constructor(private http: HttpClient) {\r\n    this.initializeWebSocket();\r\n  }\r\n\r\n  private initializeWebSocket(): void {\r\n    this.socket = io('http://localhost:3000', {\r\n      reconnection: true,\r\n      reconnectionDelay: 1000,\r\n      reconnectionAttempts: 5\r\n    });\r\n\r\n    this.socket.on('connect', () => {\r\n      console.log('WebSocket connected');\r\n      this.connectionStatusSubject.next(true);\r\n    });\r\n\r\n    \r\n\r\n    this.socket.on('disconnect', () => {\r\n      console.log('WebSocket disconnected');\r\n      this.connectionStatusSubject.next(false);\r\n    });\r\n\r\n    this.socket.on('parking-update', (update: ParkingUpdate) => {\r\n      this.parkingUpdateSubject.next(update);\r\n      this.updateLocalParkingLot(update);\r\n    });\r\n\r\n    this.socket.on('connect_error', (error) => {\r\n      console.error('WebSocket connection error:', error);\r\n    });\r\n  }\r\n\r\n  private updateLocalParkingLot(update: ParkingUpdate): void {\r\n    const currentLots = this.parkingLotsSubject.value;\r\n    const updatedLots = currentLots.map(lot => \r\n      lot.id === update.lotId \r\n        ? { ...lot, availableSpots: update.availableSpots, lastUpdate: update.timestamp }\r\n        : lot\r\n    );\r\n    this.parkingLotsSubject.next(updatedLots);\r\n  }\r\n\r\n  // Add this property at the top of the class\r\nprivate useRealData = true; // Toggle this to switch data sources\r\n\r\nprivate lotsBasePath(): string {\r\n  return this.useRealData ? `${this.apiUrl}/parking-lots/real` : `${this.apiUrl}/parking-lots`;\r\n}\r\n\r\ngetAllParkingLots(lat?: number, lng?: number, radius?: number) {\r\n  // Only the 'real' path uses lat/lng/radius; the simulated one ignores them\r\n  let endpoint = this.lotsBasePath();\r\n\r\n  if (this.useRealData) {\r\n    // defaults if not passed (ASU)\r\n    const qLat = (lat ?? 33.4242).toFixed(6);\r\n    const qLng = (lng ?? -111.9281).toFixed(6);\r\n    const qRad = radius ?? 5000; // meters\r\n    endpoint = `${endpoint}?lat=${qLat}&lng=${qLng}&radius=${qRad}`;\r\n  }\r\n\r\n  return this.http.get<ParkingLot[]>(endpoint).pipe(\r\n    tap(lots => this.parkingLotsSubject.next(lots)),\r\n    catchError(err => { console.error('Error fetching parking lots:', err); throw err; })\r\n  );\r\n}\r\n\r\n// Add this method to toggle between real and simulated data\r\nsetUseRealData(useReal: boolean): void {\r\n  this.useRealData = useReal;\r\n}\r\n\r\n  getParkingLotById(id: string): Observable<ParkingLot> {\r\n  // IMPORTANT: hit the same source as the list:\r\n  // /real/:id when using real data, otherwise /:id\r\n  const endpoint = this.useRealData\r\n    ? `${this.lotsBasePath()}/${id}`   // -> /api/parking-lots/real/:id\r\n    : `${this.lotsBasePath()}/${id}`; // -> /api/parking-lots/:id\r\n\r\n  return this.http.get<ParkingLot>(endpoint).pipe(\r\n    catchError(error => {\r\n      console.error(`Error fetching parking lot ${id}:`, error);\r\n      throw error;\r\n    })\r\n  );\r\n}\r\n\r\n  updateParkingLot(id: string, availableSpots: number, sensors?: Sensor[]): Observable<ParkingLot> {\r\n    const body = { availableSpots, sensors };\r\n    return this.http.put<ParkingLot>(`${this.apiUrl}/parking-lots/${id}`, body).pipe(\r\n      catchError(error => {\r\n        console.error(`Error updating parking lot ${id}:`, error);\r\n        throw error;\r\n      })\r\n    );\r\n  }\r\n\r\n  getPrediction(id: string, minutesAhead: number = 30): Observable<PredictionResponse> {\r\n    const params = new HttpParams().set('minutes', minutesAhead.toString());\r\n    return this.http.get<PredictionResponse>(\r\n      `${this.apiUrl}/parking-lots/${id}/predict`,\r\n      { params }\r\n    ).pipe(\r\n      catchError(error => {\r\n        console.error(`Error fetching prediction for lot ${id}:`, error);\r\n        throw error;\r\n      })\r\n    );\r\n  }\r\n\r\n  getHistoricalData(id: string, limit: number = 100): Observable<HistoricalData[]> {\r\n    const params = new HttpParams().set('limit', limit.toString());\r\n    return this.http.get<HistoricalData[]>(\r\n      `${this.apiUrl}/parking-lots/${id}/history`,\r\n      { params }\r\n    ).pipe(\r\n      catchError(error => {\r\n        console.error(`Error fetching historical data for lot ${id}:`, error);\r\n        throw error;\r\n      })\r\n    );\r\n  }\r\n\r\n  getStats(): Observable<Stats> {\r\n    return this.http.get<Stats>(`${this.apiUrl}/stats`).pipe(\r\n      catchError(error => {\r\n        console.error('Error fetching stats:', error);\r\n        throw error;\r\n      })\r\n    );\r\n  }\r\n\r\n  createParkingLot(lot: Partial<ParkingLot>): Observable<ParkingLot> {\r\n    return this.http.post<ParkingLot>(`${this.apiUrl}/parking-lots`, lot).pipe(\r\n      tap(newLot => {\r\n        const currentLots = this.parkingLotsSubject.value;\r\n        this.parkingLotsSubject.next([...currentLots, newLot]);\r\n      }),\r\n      catchError(error => {\r\n        console.error('Error creating parking lot:', error);\r\n        throw error;\r\n      })\r\n    );\r\n  }\r\n\r\n  subscribeToParkingLot(lotId: string): void {\r\n    if (this.socket.connected) {\r\n      this.socket.emit('subscribe', lotId);\r\n      console.log(`Subscribed to parking lot: ${lotId}`);\r\n    } else {\r\n      console.warn('Socket not connected. Will subscribe when connection is established.');\r\n      this.socket.once('connect', () => {\r\n        this.socket.emit('subscribe', lotId);\r\n      });\r\n    }\r\n  }\r\n\r\n  unsubscribeFromParkingLot(lotId: string): void {\r\n    if (this.socket.connected) {\r\n      this.socket.emit('unsubscribe', lotId);\r\n      console.log(`Unsubscribed from parking lot: ${lotId}`);\r\n    }\r\n  }\r\n\r\n  getOccupancyRate(lot: ParkingLot): number {\r\n    return ((lot.totalSpots - lot.availableSpots) / lot.totalSpots) * 100;\r\n  }\r\n\r\n  getStatusLabel(lot: ParkingLot): string {\r\n    const occupancy = this.getOccupancyRate(lot);\r\n    if (occupancy < 50) return 'Available';\r\n    if (occupancy < 80) return 'Moderate';\r\n    return 'Full';\r\n  }\r\n\r\n  getStatusColor(lot: ParkingLot): string {\r\n    const occupancy = this.getOccupancyRate(lot);\r\n    if (occupancy < 50) return 'green';\r\n    if (occupancy < 80) return 'yellow';\r\n    return 'red';\r\n  }\r\n\r\n  calculateDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {\r\n    const R = 6371;\r\n    const dLat = this.toRad(lat2 - lat1);\r\n    const dLng = this.toRad(lng2 - lng1);\r\n    const a = \r\n      Math.sin(dLat / 2) * Math.sin(dLat / 2) +\r\n      Math.cos(this.toRad(lat1)) * Math.cos(this.toRad(lat2)) *\r\n      Math.sin(dLng / 2) * Math.sin(dLng / 2);\r\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n    return R * c;\r\n  }\r\n\r\n  private toRad(degrees: number): number {\r\n    return degrees * (Math.PI / 180);\r\n  }\r\n\r\n  getNearestParkingLot(userLat: number, userLng: number): Observable<ParkingLot | null> {\r\n    return this.parkingLots$.pipe(\r\n      map(lots => {\r\n        if (lots.length === 0) return null;\r\n        \r\n        let nearest = lots[0];\r\n        let minDistance = this.calculateDistance(\r\n          userLat, userLng, \r\n          nearest.location.lat, nearest.location.lng\r\n        );\r\n\r\n        lots.forEach(lot => {\r\n          const distance = this.calculateDistance(\r\n            userLat, userLng,\r\n            lot.location.lat, lot.location.lng\r\n          );\r\n          if (distance < minDistance) {\r\n            minDistance = distance;\r\n            nearest = lot;\r\n          }\r\n        });\r\n\r\n        return nearest;\r\n      })\r\n    );\r\n  }\r\n\r\n  \r\n\r\n  filterByAvailability(lots: ParkingLot[], minSpots: number): ParkingLot[] {\r\n    return lots.filter(lot => lot.availableSpots >= minSpots);\r\n  }\r\n\r\n  sortByAvailability(lots: ParkingLot[]): ParkingLot[] {\r\n    return [...lots].sort((a, b) => b.availableSpots - a.availableSpots);\r\n  }\r\n\r\n  disconnect(): void {\r\n    if (this.socket) {\r\n      this.socket.disconnect();\r\n      console.log('WebSocket disconnected manually');\r\n    }\r\n  }\r\n\r\n  reconnect(): void {\r\n    if (this.socket) {\r\n      this.socket.connect();\r\n      console.log('WebSocket reconnecting...');\r\n    }\r\n  }\r\n}"]},"metadata":{},"sourceType":"module","externalDependencies":[]}