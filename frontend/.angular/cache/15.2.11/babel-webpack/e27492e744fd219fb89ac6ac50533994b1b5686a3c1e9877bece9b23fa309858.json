{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { Component } from '@angular/core';\nimport { Subject, takeUntil } from 'rxjs';\nlet ParkingDashboardComponent = class ParkingDashboardComponent {\n  constructor(parkingService, router) {\n    this.parkingService = parkingService;\n    this.router = router;\n    this.parkingLots = [];\n    this.filteredLots = [];\n    this.selectedLot = null;\n    this.stats = null;\n    this.isLoading = false;\n    this.isConnected = false;\n    this.error = null;\n    this.filterType = 'all';\n    this.searchQuery = '';\n    /** ▼▼ Step 2: user-selectable location & distance ▼▼ */\n    this.userLat = 33.4242; // default ASU Tempe\n    this.userLng = -111.9281;\n    this.radiusMeters = 5000; // 5 km default (good for Overpass)\n    this.useMyLocationPending = false;\n    /** ▲▲ Step 2 fields ▲▲ */\n    this.destroy$ = new Subject();\n  }\n  ngOnInit() {\n    /** ▼ Restore saved location prefs if present */\n    const saved = localStorage.getItem('parkingLocationPrefs');\n    if (saved) {\n      try {\n        const {\n          lat,\n          lng,\n          radius\n        } = JSON.parse(saved);\n        if (typeof lat === 'number') this.userLat = lat;\n        if (typeof lng === 'number') this.userLng = lng;\n        if (typeof radius === 'number') this.radiusMeters = radius;\n      } catch {/* ignore */}\n    }\n    /** ▲ */\n    this.loadParkingLots();\n    this.subscribeToRealtimeUpdates();\n    this.monitorConnectionStatus();\n  }\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n    this.parkingService.disconnect();\n  }\n  /** ▼▼ Step 2: call list API with lat/lng/radius ▼▼ */\n  loadParkingLots() {\n    this.isLoading = true;\n    this.error = null;\n    // NOTE: ParkingService.getAllParkingLots(lat, lng, radius) must be updated as shared earlier.\n    this.parkingService.getAllParkingLots(this.userLat, this.userLng, this.radiusMeters).pipe(takeUntil(this.destroy$)).subscribe({\n      next: lots => {\n        this.parkingLots = lots;\n        this.applyFilters();\n        this.calculateStatsFromLots();\n        this.isLoading = false;\n        // subscribe to realtime per lot\n        lots.forEach(lot => this.parkingService.subscribeToParkingLot(lot.id));\n      },\n      error: err => {\n        this.error = 'Failed to load parking lots. Please try again.';\n        this.isLoading = false;\n        console.error(err);\n      }\n    });\n  }\n  /** ▲▲ */\n  /** ▼▼ Step 2 helpers ▼▼ */\n  saveLocationPrefs() {\n    localStorage.setItem('parkingLocationPrefs', JSON.stringify({\n      lat: this.userLat,\n      lng: this.userLng,\n      radius: this.radiusMeters\n    }));\n  }\n  useMyLocation() {\n    if (!navigator.geolocation) {\n      this.error = 'Geolocation not supported on this device.';\n      return;\n    }\n    this.useMyLocationPending = true;\n    navigator.geolocation.getCurrentPosition(pos => {\n      this.userLat = Number(pos.coords.latitude.toFixed(6));\n      this.userLng = Number(pos.coords.longitude.toFixed(6));\n      this.useMyLocationPending = false;\n      this.saveLocationPrefs();\n      this.loadParkingLots();\n    }, err => {\n      console.error('Geolocation error:', err);\n      this.useMyLocationPending = false;\n      this.error = 'Unable to fetch your current location.';\n    }, {\n      enableHighAccuracy: true,\n      timeout: 10000\n    });\n  }\n  applyLocationAndSearch() {\n    // Clamp radius to safe Overpass range 1–20 km\n    const min = 1000,\n      max = 20000;\n    if (this.radiusMeters < min) this.radiusMeters = min;\n    if (this.radiusMeters > max) this.radiusMeters = max;\n    this.saveLocationPrefs();\n    this.loadParkingLots();\n  }\n  // convenient binding for a slider in km if you add it in the template\n  get radiusKm() {\n    return Math.round(this.radiusMeters / 1000);\n  }\n  set radiusKm(km) {\n    this.radiusMeters = km * 1000;\n  }\n  /** ▲▲ */\n  calculateStatsFromLots() {\n    if (this.parkingLots.length > 0) {\n      const totalSpots = this.parkingLots.reduce((sum, lot) => sum + lot.totalSpots, 0);\n      const totalAvailable = this.parkingLots.reduce((sum, lot) => sum + lot.availableSpots, 0);\n      const avgOccupancy = (totalSpots - totalAvailable) / totalSpots * 100;\n      this.stats = {\n        totalParkingLots: this.parkingLots.length,\n        totalSpots,\n        totalAvailable,\n        avgOccupancy: parseFloat(avgOccupancy.toFixed(1))\n      };\n    }\n  }\n  subscribeToRealtimeUpdates() {\n    this.parkingService.parkingUpdates$.pipe(takeUntil(this.destroy$)).subscribe({\n      next: update => {\n        const lotIndex = this.parkingLots.findIndex(lot => lot.id === update.lotId);\n        if (lotIndex !== -1) {\n          this.parkingLots[lotIndex] = {\n            ...this.parkingLots[lotIndex],\n            availableSpots: update.availableSpots,\n            lastUpdate: update.timestamp\n          };\n          this.applyFilters();\n        }\n        if (this.selectedLot?.id === update.lotId) {\n          this.selectedLot = {\n            ...this.selectedLot,\n            availableSpots: update.availableSpots,\n            lastUpdate: update.timestamp\n          };\n        }\n        this.calculateStatsFromLots();\n      },\n      error: err => {\n        console.error('Real-time update error:', err);\n      }\n    });\n  }\n  monitorConnectionStatus() {\n    this.parkingService.connectionStatus$.pipe(takeUntil(this.destroy$)).subscribe({\n      next: status => {\n        this.isConnected = status;\n        if (!status) {\n          console.warn('WebSocket disconnected. Will attempt to reconnect...');\n        }\n      }\n    });\n  }\n  selectLot(lot) {\n    this.router.navigate(['/parking', lot.id]);\n  }\n  refreshData() {\n    this.loadParkingLots();\n  }\n  setFilter(filter) {\n    this.filterType = filter;\n    this.applyFilters();\n  }\n  onSearchChange(query) {\n    this.searchQuery = query;\n    this.applyFilters();\n  }\n  applyFilters() {\n    let filtered = [...this.parkingLots];\n    if (this.filterType !== 'all') {\n      filtered = filtered.filter(lot => {\n        const occupancy = this.getOccupancyRate(lot);\n        switch (this.filterType) {\n          case 'available':\n            return occupancy < 50;\n          case 'moderate':\n            return occupancy >= 50 && occupancy < 80;\n          case 'full':\n            return occupancy >= 80;\n          default:\n            return true;\n        }\n      });\n    }\n    if (this.searchQuery.trim()) {\n      const query = this.searchQuery.toLowerCase();\n      filtered = filtered.filter(lot => lot.name.toLowerCase().includes(query));\n    }\n    this.filteredLots = filtered;\n  }\n  getOccupancyRate(lot) {\n    return (lot.totalSpots - lot.availableSpots) / lot.totalSpots * 100;\n  }\n  getStatusLabel(lot) {\n    const occupancy = this.getOccupancyRate(lot);\n    if (occupancy < 50) return 'Available';\n    if (occupancy < 80) return 'Moderate';\n    return 'Full';\n  }\n  getStatusColor(lot) {\n    const occupancy = this.getOccupancyRate(lot);\n    if (occupancy < 50) return 'green';\n    if (occupancy < 80) return 'yellow';\n    return 'red';\n  }\n  formatLastUpdate(timestamp) {\n    const date = new Date(timestamp);\n    return date.toLocaleTimeString();\n  }\n  getTimeDifference(lot) {\n    return lot.predictedAvailability - lot.availableSpots;\n  }\n  getTrendIcon(lot) {\n    const diff = this.getTimeDifference(lot);\n    if (diff > 0) return '↑';\n    if (diff < 0) return '↓';\n    return '→';\n  }\n  getTrendMessage(lot) {\n    const diff = this.getTimeDifference(lot);\n    if (diff > 5) return 'More spots expected to open up soon!';\n    if (diff < -5) return 'Spots are filling up. Consider arriving soon.';\n    return 'Availability expected to remain stable.';\n  }\n  openInMaps(lot) {\n    const url = `https://www.google.com/maps?q=${lot.location.lat},${lot.location.lng}`;\n    window.open(url, '_blank');\n  }\n  getDirections(lot) {\n    if (navigator.geolocation) {\n      navigator.geolocation.getCurrentPosition(position => {\n        const {\n          latitude,\n          longitude\n        } = position.coords;\n        const url = `https://www.google.com/maps/dir/${latitude},${longitude}/${lot.location.lat},${lot.location.lng}`;\n        window.open(url, '_blank');\n      }, error => {\n        console.error('Geolocation error:', error);\n        this.openInMaps(lot);\n      });\n    } else {\n      this.openInMaps(lot);\n    }\n  }\n};\nParkingDashboardComponent = __decorate([Component({\n  selector: 'app-parking-dashboard',\n  templateUrl: './parking-dashboard.component.html',\n  styleUrls: ['./parking-dashboard.component.css']\n})], ParkingDashboardComponent);\nexport { ParkingDashboardComponent };","map":{"version":3,"mappings":"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","names":["Component","Subject","takeUntil","ParkingDashboardComponent","constructor","parkingService","router","ngOnInit","saved","localStorage","getItem","lat","lng","radius","JSON","parse","userLat","userLng","radiusMeters","loadParkingLots","subscribeToRealtimeUpdates","monitorConnectionStatus","ngOnDestroy","destroy$","next","complete","disconnect","isLoading","error","getAllParkingLots","pipe","subscribe","lots","parkingLots","applyFilters","calculateStatsFromLots","forEach","lot","subscribeToParkingLot","id","err","console","saveLocationPrefs","setItem","stringify","useMyLocation","navigator","geolocation","useMyLocationPending","getCurrentPosition","pos","Number","coords","latitude","toFixed","longitude","enableHighAccuracy","timeout","applyLocationAndSearch","min","max","radiusKm","Math","round","km","length","totalSpots","reduce","sum","totalAvailable","availableSpots","avgOccupancy","stats","totalParkingLots","parseFloat","parkingUpdates$","update","lotIndex","findIndex","lotId","lastUpdate","timestamp","selectedLot","connectionStatus$","status","isConnected","warn","selectLot","navigate","refreshData","setFilter","filter","filterType","onSearchChange","query","searchQuery","filtered","occupancy","getOccupancyRate","trim","toLowerCase","name","includes","filteredLots","getStatusLabel","getStatusColor","formatLastUpdate","date","Date","toLocaleTimeString","getTimeDifference","predictedAvailability","getTrendIcon","diff","getTrendMessage","openInMaps","url","location","window","open","getDirections","position","selector","templateUrl","styleUrls"],"sourceRoot":"","sources":["C:\\Users\\abhij\\Documents\\Smart-AI Parking Finder\\frontend\\src\\app\\components\\parking-dashboard\\parking-dashboard.component.ts"],"sourcesContent":["import { Component, OnInit, OnDestroy } from '@angular/core';\r\nimport { Subject, takeUntil } from 'rxjs';\r\nimport { ParkingService, ParkingLot, Stats } from '../../services/parking.service';\r\nimport { Router } from '@angular/router';\r\n\r\n@Component({\r\n  selector: 'app-parking-dashboard',\r\n  templateUrl: './parking-dashboard.component.html',\r\n  styleUrls: ['./parking-dashboard.component.css']\r\n})\r\nexport class ParkingDashboardComponent implements OnInit, OnDestroy {\r\n  parkingLots: ParkingLot[] = [];\r\n  filteredLots: ParkingLot[] = [];\r\n  selectedLot: ParkingLot | null = null;\r\n  stats: Stats | null = null;\r\n\r\n  isLoading = false;\r\n  isConnected = false;\r\n  error: string | null = null;\r\n\r\n  filterType: 'all' | 'available' | 'moderate' | 'full' = 'all';\r\n  searchQuery = '';\r\n\r\n  /** ▼▼ Step 2: user-selectable location & distance ▼▼ */\r\n  userLat: number = 33.4242;          // default ASU Tempe\r\n  userLng: number = -111.9281;\r\n  radiusMeters: number = 5000;        // 5 km default (good for Overpass)\r\n  useMyLocationPending = false;\r\n  /** ▲▲ Step 2 fields ▲▲ */\r\n\r\n  private destroy$ = new Subject<void>();\r\n\r\n  constructor(private parkingService: ParkingService, private router: Router) {}\r\n\r\n  ngOnInit(): void {\r\n    /** ▼ Restore saved location prefs if present */\r\n    const saved = localStorage.getItem('parkingLocationPrefs');\r\n    if (saved) {\r\n      try {\r\n        const { lat, lng, radius } = JSON.parse(saved);\r\n        if (typeof lat === 'number') this.userLat = lat;\r\n        if (typeof lng === 'number') this.userLng = lng;\r\n        if (typeof radius === 'number') this.radiusMeters = radius;\r\n      } catch { /* ignore */ }\r\n    }\r\n    /** ▲ */\r\n\r\n    this.loadParkingLots();\r\n    this.subscribeToRealtimeUpdates();\r\n    this.monitorConnectionStatus();\r\n  }\r\n\r\n  ngOnDestroy(): void {\r\n    this.destroy$.next();\r\n    this.destroy$.complete();\r\n    this.parkingService.disconnect();\r\n  }\r\n\r\n  /** ▼▼ Step 2: call list API with lat/lng/radius ▼▼ */\r\n  loadParkingLots(): void {\r\n    this.isLoading = true;\r\n    this.error = null;\r\n\r\n    // NOTE: ParkingService.getAllParkingLots(lat, lng, radius) must be updated as shared earlier.\r\n    this.parkingService.getAllParkingLots(this.userLat, this.userLng, this.radiusMeters)\r\n      .pipe(takeUntil(this.destroy$))\r\n      .subscribe({\r\n        next: (lots) => {\r\n          this.parkingLots = lots;\r\n          this.applyFilters();\r\n          this.calculateStatsFromLots();\r\n          this.isLoading = false;\r\n\r\n          // subscribe to realtime per lot\r\n          lots.forEach(lot => this.parkingService.subscribeToParkingLot(lot.id));\r\n        },\r\n        error: (err) => {\r\n          this.error = 'Failed to load parking lots. Please try again.';\r\n          this.isLoading = false;\r\n          console.error(err);\r\n        }\r\n      });\r\n  }\r\n  /** ▲▲ */\r\n\r\n  /** ▼▼ Step 2 helpers ▼▼ */\r\n  saveLocationPrefs(): void {\r\n    localStorage.setItem('parkingLocationPrefs', JSON.stringify({\r\n      lat: this.userLat, lng: this.userLng, radius: this.radiusMeters\r\n    }));\r\n  }\r\n\r\n  useMyLocation(): void {\r\n    if (!navigator.geolocation) {\r\n      this.error = 'Geolocation not supported on this device.';\r\n      return;\r\n    }\r\n    this.useMyLocationPending = true;\r\n    navigator.geolocation.getCurrentPosition(\r\n      pos => {\r\n        this.userLat = Number(pos.coords.latitude.toFixed(6));\r\n        this.userLng = Number(pos.coords.longitude.toFixed(6));\r\n        this.useMyLocationPending = false;\r\n        this.saveLocationPrefs();\r\n        this.loadParkingLots();\r\n      },\r\n      err => {\r\n        console.error('Geolocation error:', err);\r\n        this.useMyLocationPending = false;\r\n        this.error = 'Unable to fetch your current location.';\r\n      },\r\n      { enableHighAccuracy: true, timeout: 10000 }\r\n    );\r\n  }\r\n\r\n  applyLocationAndSearch(): void {\r\n    // Clamp radius to safe Overpass range 1–20 km\r\n    const min = 1000, max = 20000;\r\n    if (this.radiusMeters < min) this.radiusMeters = min;\r\n    if (this.radiusMeters > max) this.radiusMeters = max;\r\n\r\n    this.saveLocationPrefs();\r\n    this.loadParkingLots();\r\n  }\r\n\r\n  // convenient binding for a slider in km if you add it in the template\r\n  get radiusKm(): number { return Math.round(this.radiusMeters / 1000); }\r\n  set radiusKm(km: number) { this.radiusMeters = km * 1000; }\r\n  /** ▲▲ */\r\n\r\n  calculateStatsFromLots(): void {\r\n    if (this.parkingLots.length > 0) {\r\n      const totalSpots = this.parkingLots.reduce((sum, lot) => sum + lot.totalSpots, 0);\r\n      const totalAvailable = this.parkingLots.reduce((sum, lot) => sum + lot.availableSpots, 0);\r\n      const avgOccupancy = ((totalSpots - totalAvailable) / totalSpots * 100);\r\n\r\n      this.stats = {\r\n        totalParkingLots: this.parkingLots.length,\r\n        totalSpots,\r\n        totalAvailable,\r\n        avgOccupancy: parseFloat(avgOccupancy.toFixed(1))\r\n      };\r\n    }\r\n  }\r\n\r\n  subscribeToRealtimeUpdates(): void {\r\n    this.parkingService.parkingUpdates$\r\n      .pipe(takeUntil(this.destroy$))\r\n      .subscribe({\r\n        next: (update) => {\r\n          const lotIndex = this.parkingLots.findIndex(lot => lot.id === update.lotId);\r\n          if (lotIndex !== -1) {\r\n            this.parkingLots[lotIndex] = {\r\n              ...this.parkingLots[lotIndex],\r\n              availableSpots: update.availableSpots,\r\n              lastUpdate: update.timestamp\r\n            };\r\n            this.applyFilters();\r\n          }\r\n\r\n          if (this.selectedLot?.id === update.lotId) {\r\n            this.selectedLot = {\r\n              ...this.selectedLot,\r\n              availableSpots: update.availableSpots,\r\n              lastUpdate: update.timestamp\r\n            };\r\n          }\r\n\r\n          this.calculateStatsFromLots();\r\n        },\r\n        error: (err) => {\r\n          console.error('Real-time update error:', err);\r\n        }\r\n      });\r\n  }\r\n\r\n  monitorConnectionStatus(): void {\r\n    this.parkingService.connectionStatus$\r\n      .pipe(takeUntil(this.destroy$))\r\n      .subscribe({\r\n        next: (status) => {\r\n          this.isConnected = status;\r\n          if (!status) {\r\n            console.warn('WebSocket disconnected. Will attempt to reconnect...');\r\n          }\r\n        }\r\n      });\r\n  }\r\n\r\n  selectLot(lot: ParkingLot): void {\r\n    this.router.navigate(['/parking', lot.id]);\r\n  }\r\n\r\n  refreshData(): void {\r\n    this.loadParkingLots();\r\n  }\r\n\r\n  setFilter(filter: 'all' | 'available' | 'moderate' | 'full'): void {\r\n    this.filterType = filter;\r\n    this.applyFilters();\r\n  }\r\n\r\n  onSearchChange(query: string): void {\r\n    this.searchQuery = query;\r\n    this.applyFilters();\r\n  }\r\n\r\n  applyFilters(): void {\r\n    let filtered = [...this.parkingLots];\r\n\r\n    if (this.filterType !== 'all') {\r\n      filtered = filtered.filter(lot => {\r\n        const occupancy = this.getOccupancyRate(lot);\r\n        switch (this.filterType) {\r\n          case 'available': return occupancy < 50;\r\n          case 'moderate':  return occupancy >= 50 && occupancy < 80;\r\n          case 'full':      return occupancy >= 80;\r\n          default:          return true;\r\n        }\r\n      });\r\n    }\r\n\r\n    if (this.searchQuery.trim()) {\r\n      const query = this.searchQuery.toLowerCase();\r\n      filtered = filtered.filter(lot => lot.name.toLowerCase().includes(query));\r\n    }\r\n\r\n    this.filteredLots = filtered;\r\n  }\r\n\r\n  getOccupancyRate(lot: ParkingLot): number {\r\n    return ((lot.totalSpots - lot.availableSpots) / lot.totalSpots) * 100;\r\n  }\r\n\r\n  getStatusLabel(lot: ParkingLot): string {\r\n    const occupancy = this.getOccupancyRate(lot);\r\n    if (occupancy < 50) return 'Available';\r\n    if (occupancy < 80) return 'Moderate';\r\n    return 'Full';\r\n  }\r\n\r\n  getStatusColor(lot: ParkingLot): string {\r\n    const occupancy = this.getOccupancyRate(lot);\r\n    if (occupancy < 50) return 'green';\r\n    if (occupancy < 80) return 'yellow';\r\n    return 'red';\r\n  }\r\n\r\n  formatLastUpdate(timestamp: string): string {\r\n    const date = new Date(timestamp);\r\n    return date.toLocaleTimeString();\r\n  }\r\n\r\n  getTimeDifference(lot: ParkingLot): number {\r\n    return lot.predictedAvailability - lot.availableSpots;\r\n  }\r\n\r\n  getTrendIcon(lot: ParkingLot): string {\r\n    const diff = this.getTimeDifference(lot);\r\n    if (diff > 0) return '↑';\r\n    if (diff < 0) return '↓';\r\n    return '→';\r\n  }\r\n\r\n  getTrendMessage(lot: ParkingLot): string {\r\n    const diff = this.getTimeDifference(lot);\r\n    if (diff > 5) return 'More spots expected to open up soon!';\r\n    if (diff < -5) return 'Spots are filling up. Consider arriving soon.';\r\n    return 'Availability expected to remain stable.';\r\n  }\r\n\r\n  openInMaps(lot: ParkingLot): void {\r\n    const url = `https://www.google.com/maps?q=${lot.location.lat},${lot.location.lng}`;\r\n    window.open(url, '_blank');\r\n  }\r\n\r\n  getDirections(lot: ParkingLot): void {\r\n    if (navigator.geolocation) {\r\n      navigator.geolocation.getCurrentPosition(\r\n        (position) => {\r\n          const { latitude, longitude } = position.coords;\r\n          const url = `https://www.google.com/maps/dir/${latitude},${longitude}/${lot.location.lat},${lot.location.lng}`;\r\n          window.open(url, '_blank');\r\n        },\r\n        (error) => {\r\n          console.error('Geolocation error:', error);\r\n          this.openInMaps(lot);\r\n        }\r\n      );\r\n    } else {\r\n      this.openInMaps(lot);\r\n    }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}