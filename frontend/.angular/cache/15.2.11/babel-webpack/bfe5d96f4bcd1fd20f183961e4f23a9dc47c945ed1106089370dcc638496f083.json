{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { Component } from '@angular/core';\nimport { Subject, takeUntil } from 'rxjs';\nlet ParkingDashboardComponent = class ParkingDashboardComponent {\n  constructor(parkingService, router) {\n    this.parkingService = parkingService;\n    this.router = router;\n    this.parkingLots = [];\n    this.filteredLots = [];\n    this.selectedLot = null;\n    this.stats = null;\n    this.isLoading = false;\n    this.isConnected = false;\n    this.error = null;\n    this.filterType = 'all';\n    this.searchQuery = '';\n    // ADD RADIUS PROPERTIES\n    this.selectedRadius = 5000; // Default 5km\n    this.radiusOptions = [{\n      label: '1 km',\n      value: 1000\n    }, {\n      label: '5 km',\n      value: 5000\n    }, {\n      label: '10 km',\n      value: 10000\n    }, {\n      label: '25 km',\n      value: 25000\n    }, {\n      label: '50 km',\n      value: 50000\n    }];\n    this.destroy$ = new Subject();\n  }\n  ngOnInit() {\n    this.loadParkingLots();\n    this.subscribeToRealtimeUpdates();\n    this.monitorConnectionStatus();\n  }\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n    this.parkingService.disconnect();\n  }\n  loadParkingLots() {\n    this.isLoading = true;\n    this.error = null;\n    this.parkingService.getAllParkingLots().pipe(takeUntil(this.destroy$)).subscribe({\n      next: lots => {\n        this.parkingLots = lots;\n        this.applyFilters();\n        this.calculateStatsFromLots();\n        this.isLoading = false;\n        lots.forEach(lot => this.parkingService.subscribeToParkingLot(lot.id));\n      },\n      error: err => {\n        this.error = 'Failed to load parking lots. Please try again.';\n        this.isLoading = false;\n        console.error(err);\n      }\n    });\n  }\n  calculateStatsFromLots() {\n    if (this.parkingLots.length > 0) {\n      const totalSpots = this.parkingLots.reduce((sum, lot) => sum + lot.totalSpots, 0);\n      const totalAvailable = this.parkingLots.reduce((sum, lot) => sum + lot.availableSpots, 0);\n      const avgOccupancy = (totalSpots - totalAvailable) / totalSpots * 100;\n      this.stats = {\n        totalParkingLots: this.parkingLots.length,\n        totalSpots,\n        totalAvailable,\n        avgOccupancy: parseFloat(avgOccupancy.toFixed(1))\n      };\n    }\n  }\n  // ADD RADIUS CHANGE METHOD\n  onRadiusChange(radius) {\n    this.selectedRadius = radius;\n    this.parkingService.setRadius(radius);\n    this.loadParkingLots();\n  }\n  // ADD USE MY LOCATION METHOD (BONUS)\n  useMyLocation() {\n    if (navigator.geolocation) {\n      this.isLoading = true;\n      navigator.geolocation.getCurrentPosition(position => {\n        const {\n          latitude,\n          longitude\n        } = position.coords;\n        this.parkingService.setLocation(latitude, longitude);\n        this.loadParkingLots();\n      }, error => {\n        console.error('Geolocation error:', error);\n        this.error = 'Could not get your location. Using default location.';\n        this.isLoading = false;\n      });\n    } else {\n      this.error = 'Geolocation not supported by your browser.';\n    }\n  }\n  subscribeToRealtimeUpdates() {\n    this.parkingService.parkingUpdates$.pipe(takeUntil(this.destroy$)).subscribe({\n      next: update => {\n        const lotIndex = this.parkingLots.findIndex(lot => lot.id === update.lotId);\n        if (lotIndex !== -1) {\n          this.parkingLots[lotIndex] = {\n            ...this.parkingLots[lotIndex],\n            availableSpots: update.availableSpots,\n            lastUpdate: update.timestamp\n          };\n          this.applyFilters();\n          this.calculateStatsFromLots();\n        }\n        if (this.selectedLot?.id === update.lotId) {\n          this.selectedLot = {\n            ...this.selectedLot,\n            availableSpots: update.availableSpots,\n            lastUpdate: update.timestamp\n          };\n        }\n      },\n      error: err => console.error('Real-time update error:', err)\n    });\n  }\n  monitorConnectionStatus() {\n    this.parkingService.connectionStatus$.pipe(takeUntil(this.destroy$)).subscribe({\n      next: status => this.isConnected = status\n    });\n  }\n  selectLot(lot) {\n    this.router.navigate(['/parking', lot.id]);\n  }\n  refreshData() {\n    this.loadParkingLots();\n  }\n  setFilter(filter) {\n    this.filterType = filter;\n    this.applyFilters();\n  }\n  onSearchChange(query) {\n    this.searchQuery = query;\n    this.applyFilters();\n  }\n  applyFilters() {\n    let filtered = [...this.parkingLots];\n    if (this.filterType !== 'all') {\n      filtered = filtered.filter(lot => {\n        const occupancy = this.getOccupancyRate(lot);\n        switch (this.filterType) {\n          case 'available':\n            return occupancy < 50;\n          case 'moderate':\n            return occupancy >= 50 && occupancy < 80;\n          case 'full':\n            return occupancy >= 80;\n          default:\n            return true;\n        }\n      });\n    }\n    if (this.searchQuery.trim()) {\n      const query = this.searchQuery.toLowerCase();\n      filtered = filtered.filter(lot => lot.name.toLowerCase().includes(query));\n    }\n    this.filteredLots = filtered;\n  }\n  getOccupancyRate(lot) {\n    return (lot.totalSpots - lot.availableSpots) / lot.totalSpots * 100;\n  }\n  getStatusLabel(lot) {\n    const occupancy = this.getOccupancyRate(lot);\n    if (occupancy < 50) return 'Available';\n    if (occupancy < 80) return 'Moderate';\n    return 'Full';\n  }\n  getStatusColor(lot) {\n    const occupancy = this.getOccupancyRate(lot);\n    if (occupancy < 50) return 'green';\n    if (occupancy < 80) return 'yellow';\n    return 'red';\n  }\n  formatLastUpdate(timestamp) {\n    const date = new Date(timestamp);\n    return date.toLocaleTimeString();\n  }\n  getTimeDifference(lot) {\n    return lot.predictedAvailability - lot.availableSpots;\n  }\n  getTrendIcon(lot) {\n    const diff = this.getTimeDifference(lot);\n    if (diff > 0) return '↑';\n    if (diff < 0) return '↓';\n    return '→';\n  }\n  getTrendMessage(lot) {\n    const diff = this.getTimeDifference(lot);\n    if (diff > 5) return 'More spots expected to open up soon!';\n    if (diff < -5) return 'Spots are filling up. Consider arriving soon.';\n    return 'Availability expected to remain stable.';\n  }\n  openInMaps(lot) {\n    const url = `https://www.google.com/maps?q=${lot.location.lat},${lot.location.lng}`;\n    window.open(url, '_blank');\n  }\n  getDirections(lot) {\n    if (navigator.geolocation) {\n      navigator.geolocation.getCurrentPosition(position => {\n        const {\n          latitude,\n          longitude\n        } = position.coords;\n        const url = `https://www.google.com/maps/dir/${latitude},${longitude}/${lot.location.lat},${lot.location.lng}`;\n        window.open(url, '_blank');\n      }, error => {\n        console.error('Geolocation error:', error);\n        this.openInMaps(lot);\n      });\n    } else {\n      this.openInMaps(lot);\n    }\n  }\n};\nParkingDashboardComponent = __decorate([Component({\n  selector: 'app-parking-dashboard',\n  templateUrl: './parking-dashboard.component.html',\n  styleUrls: ['./parking-dashboard.component.css']\n})], ParkingDashboardComponent);\nexport { ParkingDashboardComponent };","map":{"version":3,"mappings":"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","names":["Component","Subject","takeUntil","ParkingDashboardComponent","constructor","parkingService","router","label","value","ngOnInit","loadParkingLots","subscribeToRealtimeUpdates","monitorConnectionStatus","ngOnDestroy","destroy$","next","complete","disconnect","isLoading","error","getAllParkingLots","pipe","subscribe","lots","parkingLots","applyFilters","calculateStatsFromLots","forEach","lot","subscribeToParkingLot","id","err","console","length","totalSpots","reduce","sum","totalAvailable","availableSpots","avgOccupancy","stats","totalParkingLots","parseFloat","toFixed","onRadiusChange","radius","selectedRadius","setRadius","useMyLocation","navigator","geolocation","getCurrentPosition","position","latitude","longitude","coords","setLocation","parkingUpdates$","update","lotIndex","findIndex","lotId","lastUpdate","timestamp","selectedLot","connectionStatus$","status","isConnected","selectLot","navigate","refreshData","setFilter","filter","filterType","onSearchChange","query","searchQuery","filtered","occupancy","getOccupancyRate","trim","toLowerCase","name","includes","filteredLots","getStatusLabel","getStatusColor","formatLastUpdate","date","Date","toLocaleTimeString","getTimeDifference","predictedAvailability","getTrendIcon","diff","getTrendMessage","openInMaps","url","location","lat","lng","window","open","getDirections","selector","templateUrl","styleUrls"],"sourceRoot":"","sources":["C:\\Users\\abhij\\Documents\\Smart-AI Parking Finder\\frontend\\src\\app\\components\\parking-dashboard\\parking-dashboard.component.ts"],"sourcesContent":["import { Component, OnInit, OnDestroy } from '@angular/core';\r\nimport { Subject, takeUntil } from 'rxjs';\r\nimport { ParkingService, ParkingLot, Stats } from '../../services/parking.service';\r\nimport { Router } from '@angular/router';\r\n\r\n@Component({\r\n  selector: 'app-parking-dashboard',\r\n  templateUrl: './parking-dashboard.component.html',\r\n  styleUrls: ['./parking-dashboard.component.css']\r\n})\r\nexport class ParkingDashboardComponent implements OnInit, OnDestroy {\r\n  parkingLots: ParkingLot[] = [];\r\n  filteredLots: ParkingLot[] = [];\r\n  selectedLot: ParkingLot | null = null;\r\n  stats: Stats | null = null;\r\n\r\n  isLoading = false;\r\n  isConnected = false;\r\n  error: string | null = null;\r\n\r\n  filterType: 'all' | 'available' | 'moderate' | 'full' = 'all';\r\n  searchQuery = '';\r\n\r\n  // ADD RADIUS PROPERTIES\r\n  selectedRadius = 5000; // Default 5km\r\n  radiusOptions = [\r\n    { label: '1 km', value: 1000 },\r\n    { label: '5 km', value: 5000 },\r\n    { label: '10 km', value: 10000 },\r\n    { label: '25 km', value: 25000 },\r\n    { label: '50 km', value: 50000 }\r\n  ];\r\n\r\n  private destroy$ = new Subject<void>();\r\n\r\n  constructor(private parkingService: ParkingService, private router: Router) {}\r\n\r\n  ngOnInit(): void {\r\n    this.loadParkingLots();\r\n    this.subscribeToRealtimeUpdates();\r\n    this.monitorConnectionStatus();\r\n  }\r\n\r\n  ngOnDestroy(): void {\r\n    this.destroy$.next();\r\n    this.destroy$.complete();\r\n    this.parkingService.disconnect();\r\n  }\r\n\r\n  loadParkingLots(): void {\r\n    this.isLoading = true;\r\n    this.error = null;\r\n\r\n    this.parkingService.getAllParkingLots()\r\n      .pipe(takeUntil(this.destroy$))\r\n      .subscribe({\r\n        next: (lots) => {\r\n          this.parkingLots = lots;\r\n          this.applyFilters();\r\n          this.calculateStatsFromLots();\r\n          this.isLoading = false;\r\n\r\n          lots.forEach(lot => this.parkingService.subscribeToParkingLot(lot.id));\r\n        },\r\n        error: (err) => {\r\n          this.error = 'Failed to load parking lots. Please try again.';\r\n          this.isLoading = false;\r\n          console.error(err);\r\n        }\r\n      });\r\n  }\r\n\r\n  calculateStatsFromLots(): void {\r\n    if (this.parkingLots.length > 0) {\r\n      const totalSpots = this.parkingLots.reduce((sum, lot) => sum + lot.totalSpots, 0);\r\n      const totalAvailable = this.parkingLots.reduce((sum, lot) => sum + lot.availableSpots, 0);\r\n      const avgOccupancy = ((totalSpots - totalAvailable) / totalSpots * 100);\r\n\r\n      this.stats = {\r\n        totalParkingLots: this.parkingLots.length,\r\n        totalSpots,\r\n        totalAvailable,\r\n        avgOccupancy: parseFloat(avgOccupancy.toFixed(1))\r\n      };\r\n    }\r\n  }\r\n\r\n  // ADD RADIUS CHANGE METHOD\r\n  onRadiusChange(radius: number): void {\r\n    this.selectedRadius = radius;\r\n    this.parkingService.setRadius(radius);\r\n    this.loadParkingLots();\r\n  }\r\n\r\n  // ADD USE MY LOCATION METHOD (BONUS)\r\n  useMyLocation(): void {\r\n    if (navigator.geolocation) {\r\n      this.isLoading = true;\r\n      navigator.geolocation.getCurrentPosition(\r\n        (position) => {\r\n          const { latitude, longitude } = position.coords;\r\n          this.parkingService.setLocation(latitude, longitude);\r\n          this.loadParkingLots();\r\n        },\r\n        (error) => {\r\n          console.error('Geolocation error:', error);\r\n          this.error = 'Could not get your location. Using default location.';\r\n          this.isLoading = false;\r\n        }\r\n      );\r\n    } else {\r\n      this.error = 'Geolocation not supported by your browser.';\r\n    }\r\n  }\r\n\r\n  subscribeToRealtimeUpdates(): void {\r\n    this.parkingService.parkingUpdates$\r\n      .pipe(takeUntil(this.destroy$))\r\n      .subscribe({\r\n        next: (update) => {\r\n          const lotIndex = this.parkingLots.findIndex(lot => lot.id === update.lotId);\r\n          if (lotIndex !== -1) {\r\n            this.parkingLots[lotIndex] = {\r\n              ...this.parkingLots[lotIndex],\r\n              availableSpots: update.availableSpots,\r\n              lastUpdate: update.timestamp\r\n            };\r\n            this.applyFilters();\r\n            this.calculateStatsFromLots();\r\n          }\r\n\r\n          if (this.selectedLot?.id === update.lotId) {\r\n            this.selectedLot = {\r\n              ...this.selectedLot,\r\n              availableSpots: update.availableSpots,\r\n              lastUpdate: update.timestamp\r\n            };\r\n          }\r\n        },\r\n        error: (err) => console.error('Real-time update error:', err)\r\n      });\r\n  }\r\n\r\n  monitorConnectionStatus(): void {\r\n    this.parkingService.connectionStatus$\r\n      .pipe(takeUntil(this.destroy$))\r\n      .subscribe({ next: (status) => (this.isConnected = status) });\r\n  }\r\n\r\n  selectLot(lot: ParkingLot): void {\r\n    this.router.navigate(['/parking', lot.id]);\r\n  }\r\n\r\n  refreshData(): void {\r\n    this.loadParkingLots();\r\n  }\r\n\r\n  setFilter(filter: 'all' | 'available' | 'moderate' | 'full'): void {\r\n    this.filterType = filter;\r\n    this.applyFilters();\r\n  }\r\n\r\n  onSearchChange(query: string): void {\r\n    this.searchQuery = query;\r\n    this.applyFilters();\r\n  }\r\n\r\n  applyFilters(): void {\r\n    let filtered = [...this.parkingLots];\r\n\r\n    if (this.filterType !== 'all') {\r\n      filtered = filtered.filter(lot => {\r\n        const occupancy = this.getOccupancyRate(lot);\r\n        switch (this.filterType) {\r\n          case 'available': return occupancy < 50;\r\n          case 'moderate':  return occupancy >= 50 && occupancy < 80;\r\n          case 'full':      return occupancy >= 80;\r\n          default: return true;\r\n        }\r\n      });\r\n    }\r\n\r\n    if (this.searchQuery.trim()) {\r\n      const query = this.searchQuery.toLowerCase();\r\n      filtered = filtered.filter(lot => lot.name.toLowerCase().includes(query));\r\n    }\r\n\r\n    this.filteredLots = filtered;\r\n  }\r\n\r\n  getOccupancyRate(lot: ParkingLot): number {\r\n    return ((lot.totalSpots - lot.availableSpots) / lot.totalSpots) * 100;\r\n  }\r\n\r\n  getStatusLabel(lot: ParkingLot): string {\r\n    const occupancy = this.getOccupancyRate(lot);\r\n    if (occupancy < 50) return 'Available';\r\n    if (occupancy < 80) return 'Moderate';\r\n    return 'Full';\r\n  }\r\n\r\n  getStatusColor(lot: ParkingLot): string {\r\n    const occupancy = this.getOccupancyRate(lot);\r\n    if (occupancy < 50) return 'green';\r\n    if (occupancy < 80) return 'yellow';\r\n    return 'red';\r\n  }\r\n\r\n  formatLastUpdate(timestamp: string): string {\r\n    const date = new Date(timestamp);\r\n    return date.toLocaleTimeString();\r\n  }\r\n\r\n  getTimeDifference(lot: ParkingLot): number {\r\n    return lot.predictedAvailability - lot.availableSpots;\r\n  }\r\n\r\n  getTrendIcon(lot: ParkingLot): string {\r\n    const diff = this.getTimeDifference(lot);\r\n    if (diff > 0) return '↑';\r\n    if (diff < 0) return '↓';\r\n    return '→';\r\n  }\r\n\r\n  getTrendMessage(lot: ParkingLot): string {\r\n    const diff = this.getTimeDifference(lot);\r\n    if (diff > 5) return 'More spots expected to open up soon!';\r\n    if (diff < -5) return 'Spots are filling up. Consider arriving soon.';\r\n    return 'Availability expected to remain stable.';\r\n  }\r\n\r\n  openInMaps(lot: ParkingLot): void {\r\n    const url = `https://www.google.com/maps?q=${lot.location.lat},${lot.location.lng}`;\r\n    window.open(url, '_blank');\r\n  }\r\n\r\n  getDirections(lot: ParkingLot): void {\r\n    if (navigator.geolocation) {\r\n      navigator.geolocation.getCurrentPosition(\r\n        (position) => {\r\n          const { latitude, longitude } = position.coords;\r\n          const url = `https://www.google.com/maps/dir/${latitude},${longitude}/${lot.location.lat},${lot.location.lng}`;\r\n          window.open(url, '_blank');\r\n        },\r\n        (error) => {\r\n          console.error('Geolocation error:', error);\r\n          this.openInMaps(lot);\r\n        }\r\n      );\r\n    } else {\r\n      this.openInMaps(lot);\r\n    }\r\n  }\r\n}"]},"metadata":{},"sourceType":"module","externalDependencies":[]}